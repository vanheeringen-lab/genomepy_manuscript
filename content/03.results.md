{##

    To create the webpage locally, run `build/run_on_localhost.sh` and clock the http link.
    
    Aim: up to 2 pages; this is approx. 1,300 words or 1,000 words plus one figure.
##}

## Features of genomepy
The core functionalities of genomepy are to search, download and process genomes and gene annotations.

On first use, the `search` function queries the databases of GENCODE, Ensembl, UCSC and NCBI and caches the metadata on available assemblies (for up to 7 days).
The input can be text, taxonomy identifiers or assembly accession identifiers.
The input type is automatically recognized and used to find assemblies that 
1) have the text in the genome names or various description fields, 
2) (exactly) matches the taxonomy identifier or 
3) (mostly) matches the assembly accession.
The output of the function is a table with rows of metadata for each assembly found.
This overview indicates whether a gene annotation can be downloaded for an assembly (or which of the four UCSC annotations) (see fig. 1a).
The gene annotation(s) of an assembly can be inspected with the `annotation` function (fig. 1b).

```bash
$ genomepy search GRCh38
name          provider  accession         tax_id  annotation  species                     other_info
                                                   n r e k    <- UCSC options (see help)
GRCh38        GENCODE   GCA_000001405.15    9606      ✓       Homo sapiens                GENCODE annotation + UCSC genome
GRCh38.p13    Ensembl   GCA_000001405.28    9606      ✓       Homo sapiens                2014-01-Ensembl/2021-08
hg38          UCSC      GCA_000001405.15    9606   ✓ ✓ ✗ ✓   Homo sapiens                Dec. 2013 (GRCh38/hg38)
GRCh38        NCBI      GCF_000001405.26    9606      ✓       Homo sapiens                Genome Reference Consortium
 ^
 Use name for genomepy install
```

```bash
$ genomepy annotation GRCh38.p13
12:00:00 | INFO | Ensembl
1       ensembl_havana  gene    1211340 1214153 .       -       .       gene_id "ENSG00000186827"; gene_version "11"; gene_name "TNFRSF4"; gene_source "ensembl_havana"; gene_biotype "protein_coding";
12:00:00 | INFO | NCBI
NC_000001.11    genomepy        transcript      11874   14409   .       +       .       gene_id "DDX11L1"; transcript_id "NR_046018.2";  gene_name "DDX11L1";
```

```bash
$ genomepy install --annotation GRCh38.p13
$ ls -1 ~/.local/share/genomes/GRCh38.p13
GRCh38.p13.annotation.bed
GRCh38.p13.annotation.gtf
GRCh38.p13.fa
GRCh38.p13.fa.fai
GRCh38.p13.fa.sizes
GRCh38.p13.gaps.bed
README.txt
assembly_report.txt
index/
```

{## ![workflow for `genomepy search` and `genomepy install`.](images/flow.png){#fig:flow height="400px" width="600"px}  ##}

An assembly name can be passed to the `install` function (fig. 1c).
The genome FASTA file is downloaded with the desired sequence masking level [@http://repeatmasker.org; @doi:10.1089/cmb.2006.13.1028] (softmasked by default).
Reference assemblies often contain alternate sequences to reflect biological diversity.
During sequence alignment however, similar reference sequences result in multiple alignment, leading to loss of data (as discussed in @https://doi.org/10.1186/s13059-015-0587-3). 
Therefore, genomepy downloads the primary assembly and filters out alternative sequences by default.
Additional regex filters may be passed to either include or exclude contigs (chromosomes, scaffolds, etc.) by name.
Once filtering is performed, genomepy generates a genome index using pyfaidx @https://doi.org/10.7287/peerj.preprints.970v1, and contig sizes and contig gap sizes are collected in separate files.

Gene annotations come in a variety of recognized formats (GFF3, GTF, BED12).
The `install` function can download the most descriptive format to output the commonly used GTF and BED12 formats.
Contig names of the genome and gene annotation sometimes mismatch, which makes them incompatible with tools such as splice-aware aligners.
Therefore, genomepy will attempt to match the contig names of the gene annotations to those used in the genome FASTA.

The install function can be extended with postprocessing steps via plugins.
The options can be inspected and toggled with the `plugin` function.
Briefly, the blacklist plugin downloads blacklists by the Kundaje lab @https://doi.org/10.1038/s41598-019-45839-z for the supported genomes.
Other plugins support the generation of aligner indexes, including DNA aligner indexes for Bowtie2 @https://doi.org/10.1038/nmeth.1923, BWA @https://doi.org/10.1093/bioinformatics/btp324, GMAP @https://doi.org/10.1093/bioinformatics/bti310 or Minimap2 @https://doi.org/10.1093/bioinformatics/bty191, and splice-aware aligners such as STAR @https://doi.org/10.1093/bioinformatics/bts635 and HISAT2 @https://doi.org/10.1038/nmeth.3317.

Assemblies not present on the major providers can be processed similarly by supplying the URLs or file paths to the `install` function.
For data provenance and reproducibility, a README file is generated during the installation process with time, source files, processing steps, and filtered contigs.

The core features are available on both the command line interface and Python API.
Additional features are available on the Python API, focussed around two classes.
The `Genome` class can be used to extract exact or random sequences from the FASTA, filter the FASTA and list the contigs, contig sizes and contig gaps.
The `Annotation` class can be used to browse and filter the BED12 or GTF files as pandas dataframes @https://doi.org/10.5281/zenodo.3509134, 
map gene identifiers to other types using mygene.info @https://doi.org/10.1186/s13059-016-0953-9, 
map chromosome names to naming schemes of other major providers,
and create a dictionary of any two GTF columns or attribute fields (to easily convert gene identifiers to gene names for instance).
